{"version":3,"file":"index.js","sources":["../src/TilemapContext.js","../src/getSprite.js","../src/Layer.jsx","../src/useTilemapLoader.js","../src/useObjects.js","../src/Tilemap.jsx","../src/useCollisions.js","../src/useInteractables.js","../src/useMap.js","../src/useSpawnPoint.js","../src/useTiles.js"],"sourcesContent":["import { createContext } from \"react\";\n\nconst TilemapContext = createContext()\n\nexport default TilemapContext\n","import path from 'path'\nimport { Rectangle, Texture } from 'pixi.js'\nimport { Sprite } from \"@pixi/react\"\nimport React from \"react\"\n\nconst getTilesetForGID = (gid, tilesets) => {\n    let result\n    for (const tileset of tilesets) {\n        if (gid >= tileset.firstGid) {\n            result = tileset\n        }\n    }\n    return result\n}\n\nconst getTileTexture = (tile, map, tileset) => {\n    const { image, tileHeight, tileWidth } = tileset\n    const spriteIndex = tile.gid - tileset.firstGid\n\n    const x = (spriteIndex % (image.width / tileWidth)) * tileWidth\n    const y = Math.floor(spriteIndex / (image.height / tileHeight)) * tileHeight\n\n    const rootDir = path.dirname(map.path)\n    const baseTexture = Texture.from(`${rootDir}/${tileset.image.source}`)\n\n    return new Texture(baseTexture, new Rectangle(x, y, tileHeight, tileWidth))\n}\n\nconst getTileSprite = (tileType, tile, map) => {\n    const tileset = getTilesetForGID(tile.gid, map.tileSets)\n\n    if (tileset) {\n        const { x, width, height } = tile\n        const texture = getTileTexture(tile, map, tileset)\n\n        // Objects are bottom aligned for some reason. This pushes them up so they align with the rest of the tilemap.\n        let y = tile.y\n        if (tileType === 'object') {\n            y -= height\n        }\n\n        return <Sprite key={`(${x},${y})`}\n            texture={texture}\n            x={x}\n            y={y}\n            width={width}\n            height={height}\n        />\n    }\n}\n\nexport default getTileSprite\n","import React, { useMemo } from \"react\";\nimport { Container } from \"@pixi/react\";\nimport getSprite from \"./getSprite\";\n\nconst getTileSprites = (layer, map) => {\n    const sprites = [];\n\n    for (let y = 0; y < map.height; y++) {\n        for (let x = 0; x < map.width; x++) {\n            const i = x + y * map.width;\n            const tile = layer.tiles[i];\n\n            if (tile?.gid > 0) {\n                sprites.push(getSprite(\"tile\", tile, map));\n            }\n        }\n    }\n\n    return sprites;\n};\n\nconst getObjectSprites = (layer, map) => {\n    return layer.objects.map((object) => {\n        if (object.gid) {\n            return getSprite(\"object\", object, map);\n        }\n    });\n};\n\nconst Layer = ({ layer, map }) => {\n    if (!layer.visible) {\n        return null;\n    }\n\n    const sprites = useMemo(() => {\n        if (layer.type === \"tile\") {\n            return getTileSprites(layer, map);\n        } else if (layer.type === \"object\") {\n            return getObjectSprites(layer, map);\n        }\n    }, [layer]);\n\n    return <Container alpha={layer.opacity}>{sprites}</Container>;\n};\n\nexport default Layer;\n\n","import { useEffect, useState } from 'react'\nimport tmx from 'tmx-parser'\n\ntmx.readFile = (path, callback) => {\n    fetch(path)\n        .then(response => response.text())\n        .then(text => callback(null, text))\n}\n\nconst useTilemapLoader = (tilemapPath) => {\n    const [map, setMap] = useState(null)\n\n    useEffect(() => {\n        tmx.parseFile(tilemapPath, (err, map) => {\n            if (err) throw err\n\n            // Add (x,y) coordinates to each tile so it is easy to align collision\n            // rectangles later.\n            map.layers = map.layers.map(layer => {\n                return {\n                    ...layer,\n                    tiles: layer.tiles?.map((tile, index) => {\n                        const x = (index % map.width) * map.tileWidth\n                        const y = Math.floor(index / map.width) * map.tileHeight\n                        const width = map.tileWidth\n                        const height = map.tileHeight\n\n                        return { ...tile, x, y, width, height}\n                    })\n                }\n            })\n\n            map.path = tilemapPath\n\n            setMap(map)\n        })\n    }, [ tilemapPath ])\n\n    return map\n}\n\nexport default useTilemapLoader\n","import { useContext, useMemo } from \"react\"\nimport TilemapContext from \"./TilemapContext\"\n\nconst useObjects = () => {\n    const { map } = useContext(TilemapContext)\n\n    const objects = useMemo(() => map.layers\n        .filter(layer => layer.type === 'object')\n        .map(layer => layer.objects)\n        .flat(),\n    [ map ])\n\n    return objects\n}\n\nexport default useObjects","import React, { useMemo, useState } from \"react\";\nimport { Container } from \"@pixi/react\";\nimport TilemapContext from \"./TilemapContext\";\nimport Layer from \"./Layer\";\n\nconst Tilemap = ({ map, children, ...props }) => {\n    const [hasForeground, setHasForeground] = useState(false);\n\n    const layers = useMemo(() => {\n        return map?.layers.map((layer, index) => {\n            const { name } = layer;\n            if (name === \"Foreground\") {\n                setHasForeground(true);\n                return children;\n            } else {\n                return <Layer key={index} layer={layer} map={map} />;\n            }\n        });\n    }, [map, children]);\n\n    // Only render once the map is loaded so that our hooks don't need to\n    // conditionally check if anything in TilemapContext exists.\n    if (map) {\n        return (\n            <TilemapContext.Provider value={{ map }}>\n                <Container {...props}>\n                    {layers}\n\n                    {/* If there's no foreground layer specified in the map, we simply render the children on top */}\n                    {!hasForeground && children}\n                </Container>\n            </TilemapContext.Provider>\n        );\n    } else {\n        return null;\n    }\n};\n\nexport default Tilemap;\n\n","import { Rectangle } from \"pixi.js\"\nimport { useContext, useMemo } from \"react\"\nimport TilemapContext from \"./TilemapContext\"\n\nconst useCollisions = () => {\n    const { map } = useContext(TilemapContext)\n\n    const collisions = useMemo(() => {\n        return map.layers\n            .filter(layer => layer.type === 'tile')    \n            .map(layer => {\n                const rects = []\n        \n                for (const tile of layer.tiles) {\n                    if (tile) {\n                        const { objectGroups } = tile\n        \n                        if (objectGroups.length > 0) {\n                            for (const rectangle of objectGroups) {\n                                const { x, y, width, height } = rectangle\n                                rects.push(new Rectangle(tile.x + x, tile.y + y, width, height))\n                            }\n                        }\n                    }\n                }\n        \n                return rects\n            })\n            .flat()\n    }, [ map ])\n\n    return collisions\n}\n\nexport default useCollisions","import { useMemo } from 'react'\nimport useObjects from './useObjects'\n\nconst useInteractableObjects = () => {\n    const objects = useObjects()\n\n    return useMemo(() => {\n        const interactables = []\n\n        for (const object of objects) {\n            if (object.properties.isInteractable) {\n                interactables.push(object)\n            }\n        }\n\n        return interactables\n    }, [ objects ])\n}\n\nexport default useInteractableObjects","import { useContext } from \"react\"\nimport TilemapContext from './TilemapContext'\n\nconst useMap = () => {\n    const { map } = useContext(TilemapContext)\n    return map\n}\n\nexport default useMap","import { Point } from \"pixi.js\"\nimport { useMemo } from \"react\"\nimport useObjects from \"./useObjects\"\n\nconst useSpawnPoint = () => {\n    const objects = useObjects()\n    \n    const point = useMemo(() => {\n        const spawn = objects.find(object => object.name === 'Spawn')\n        return new Point(spawn.x + spawn.width / 2, spawn.y + spawn.height / 2)\n    })\n\n    return point\n}\n\nexport default useSpawnPoint\n","import { useContext, useEffect, useState } from \"react\"\nimport TilemapContext from \"./TilemapContext\"\n\nconst useTiles = () => {\n    const { map } = useContext(TilemapContext)\n    const [tiles, set] = useState([])\n\n    useEffect(() => {\n        if (map) {\n            const newTiles = map.layers\n                .filter(layer => layer.type === 'tile')\n                .map(layer => layer.tiles)\n                .flat()\n                .filter(tile => tile !== null)\n\n            set(newTiles)\n        }\n    }, [ map ])\n\n    return tiles\n}\n\nexport default useTiles"],"names":["TilemapContext","createContext","getTileSprite","tileType","tile","map","tileset","gid","tilesets","result","firstGid","getTilesetForGID","tileSets","x","width","height","texture","image","tileHeight","tileWidth","spriteIndex","y","Math","floor","rootDir","path","dirname","baseTexture","Texture","from","source","Rectangle","getTileTexture","React","Sprite","key","Layer","layer","visible","sprites","useMemo","type","tiles","push","getSprite","getTileSprites","objects","object","getObjectSprites","Container","alpha","opacity","tmx","readFile","callback","fetch","then","response","text","useTilemapLoader","useObjects","useContext","layers","filter","flat","children","props","useState","hasForeground","setHasForeground","index","name","Provider","value","rects","objectGroups","length","rectangle","interactables","properties","isInteractable","spawn","find","Point","tilemapPath","setMap","useEffect","parseFile","err","_layer$tiles","set","newTiles"],"mappings":"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"}