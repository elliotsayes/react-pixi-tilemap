{"version":3,"file":"index.modern.js","sources":["../src/TilemapContext.js","../src/getSprite.js","../src/Layer.jsx","../src/Tilemap.jsx","../src/useTilemapLoader.js","../src/useMap.js","../src/useObjects.js","../src/useSpawnPoint.js","../src/useCollisions.js","../src/useInteractables.js","../src/useTiles.js"],"sourcesContent":["import { createContext } from \"react\";\n\nconst TilemapContext = createContext()\n\nexport default TilemapContext\n","import path from 'path'\nimport { Rectangle, Texture } from 'pixi.js'\nimport { Sprite } from \"@pixi/react\"\nimport React from \"react\"\n\nconst getTilesetForGID = (gid, tilesets) => {\n    let result\n    for (const tileset of tilesets) {\n        if (gid >= tileset.firstGid) {\n            result = tileset\n        }\n    }\n    return result\n}\n\nconst getTileTexture = (tile, map, tileset) => {\n    const { image, tileHeight, tileWidth } = tileset\n    const spriteIndex = tile.gid - tileset.firstGid\n\n    const x = (spriteIndex % (image.width / tileWidth)) * tileWidth\n    const y = Math.floor(spriteIndex / (image.height / tileHeight)) * tileHeight\n\n    const rootDir = path.dirname(map.path)\n    const baseTexture = Texture.from(`${rootDir}/${tileset.image.source}`)\n\n    return new Texture(baseTexture, new Rectangle(x, y, tileHeight, tileWidth))\n}\n\nconst getTileSprite = (tileType, tile, map) => {\n    const tileset = getTilesetForGID(tile.gid, map.tileSets)\n\n    if (tileset) {\n        const { x, width, height } = tile\n        const texture = getTileTexture(tile, map, tileset)\n\n        // Objects are bottom aligned for some reason. This pushes them up so they align with the rest of the tilemap.\n        let y = tile.y\n        if (tileType === 'object') {\n            y -= height\n        }\n\n        return <Sprite key={`(${x},${y})`}\n            texture={texture}\n            x={x}\n            y={y}\n            width={width}\n            height={height}\n        />\n    }\n}\n\nexport default getTileSprite\n","import React, { useMemo } from \"react\";\nimport { Container } from \"@pixi/react\";\nimport getSprite from \"./getSprite\";\n\nconst getTileSprites = (layer, map) => {\n    const sprites = [];\n\n    for (let y = 0; y < map.height; y++) {\n        for (let x = 0; x < map.width; x++) {\n            const i = x + y * map.width;\n            const tile = layer.tiles[i];\n\n            if (tile?.gid > 0) {\n                sprites.push(getSprite(\"tile\", tile, map));\n            }\n        }\n    }\n\n    return sprites;\n};\n\nconst getObjectSprites = (layer, map) => {\n    return layer.objects.map((object) => {\n        if (object.gid) {\n            return getSprite(\"object\", object, map);\n        }\n    });\n};\n\nconst Layer = ({ layer, map }) => {\n    if (!layer.visible) {\n        return null;\n    }\n\n    const sprites = useMemo(() => {\n        if (layer.type === \"tile\") {\n            return getTileSprites(layer, map);\n        } else if (layer.type === \"object\") {\n            return getObjectSprites(layer, map);\n        }\n    }, [layer]);\n\n    return <Container alpha={layer.opacity}>{sprites}</Container>;\n};\n\nexport default Layer;\n\n","import React, { useMemo, useState } from \"react\";\nimport { Container } from \"@pixi/react\";\nimport TilemapContext from \"./TilemapContext\";\nimport Layer from \"./Layer\";\n\nconst Tilemap = ({ map, children, ...props }) => {\n    const [hasForeground, setHasForeground] = useState(false);\n\n    const layers = useMemo(() => {\n        return map?.layers.map((layer, index) => {\n            const { name } = layer;\n            if (name === \"Foreground\") {\n                setHasForeground(true);\n                return children;\n            } else {\n                return <Layer key={index} layer={layer} map={map} />;\n            }\n        });\n    }, [map, children]);\n\n    // Only render once the map is loaded so that our hooks don't need to\n    // conditionally check if anything in TilemapContext exists.\n    if (map) {\n        return (\n            <TilemapContext.Provider value={{ map }}>\n                <Container {...props}>\n                    {layers}\n\n                    {/* If there's no foreground layer specified in the map, we simply render the children on top */}\n                    {!hasForeground && children}\n                </Container>\n            </TilemapContext.Provider>\n        );\n    } else {\n        return null;\n    }\n};\n\nexport default Tilemap;\n\n","import { useEffect, useState } from 'react'\nimport tmx from 'tmx-parser'\n\ntmx.readFile = (path, callback) => {\n    fetch(path)\n        .then(response => response.text())\n        .then(text => callback(null, text))\n}\n\nconst useTilemapLoader = (tilemapPath) => {\n    const [map, setMap] = useState(null)\n\n    useEffect(() => {\n        tmx.parseFile(tilemapPath, (err, map) => {\n            if (err) throw err\n\n            // Add (x,y) coordinates to each tile so it is easy to align collision\n            // rectangles later.\n            map.layers = map.layers.map(layer => {\n                return {\n                    ...layer,\n                    tiles: layer.tiles?.map((tile, index) => {\n                        const x = (index % map.width) * map.tileWidth\n                        const y = Math.floor(index / map.width) * map.tileHeight\n                        const width = map.tileWidth\n                        const height = map.tileHeight\n\n                        return { ...tile, x, y, width, height}\n                    })\n                }\n            })\n\n            map.path = tilemapPath\n\n            setMap(map)\n        })\n    }, [ tilemapPath ])\n\n    return map\n}\n\nexport default useTilemapLoader\n","import { useContext } from \"react\"\nimport TilemapContext from './TilemapContext'\n\nconst useMap = () => {\n    const { map } = useContext(TilemapContext)\n    return map\n}\n\nexport default useMap","import { useContext, useMemo } from \"react\"\nimport TilemapContext from \"./TilemapContext\"\n\nconst useObjects = () => {\n    const { map } = useContext(TilemapContext)\n\n    const objects = useMemo(() => map.layers\n        .filter(layer => layer.type === 'object')\n        .map(layer => layer.objects)\n        .flat(),\n    [ map ])\n\n    return objects\n}\n\nexport default useObjects","import { Point } from \"pixi.js\"\nimport { useMemo } from \"react\"\nimport useObjects from \"./useObjects\"\n\nconst useSpawnPoint = () => {\n    const objects = useObjects()\n    \n    const point = useMemo(() => {\n        const spawn = objects.find(object => object.name === 'Spawn')\n        return new Point(spawn.x + spawn.width / 2, spawn.y + spawn.height / 2)\n    })\n\n    return point\n}\n\nexport default useSpawnPoint\n","import { Rectangle } from \"pixi.js\"\nimport { useContext, useMemo } from \"react\"\nimport TilemapContext from \"./TilemapContext\"\n\nconst useCollisions = () => {\n    const { map } = useContext(TilemapContext)\n\n    const collisions = useMemo(() => {\n        return map.layers\n            .filter(layer => layer.type === 'tile')    \n            .map(layer => {\n                const rects = []\n        \n                for (const tile of layer.tiles) {\n                    if (tile) {\n                        const { objectGroups } = tile\n        \n                        if (objectGroups.length > 0) {\n                            for (const rectangle of objectGroups) {\n                                const { x, y, width, height } = rectangle\n                                rects.push(new Rectangle(tile.x + x, tile.y + y, width, height))\n                            }\n                        }\n                    }\n                }\n        \n                return rects\n            })\n            .flat()\n    }, [ map ])\n\n    return collisions\n}\n\nexport default useCollisions","import { useMemo } from 'react'\nimport useObjects from './useObjects'\n\nconst useInteractableObjects = () => {\n    const objects = useObjects()\n\n    return useMemo(() => {\n        const interactables = []\n\n        for (const object of objects) {\n            if (object.properties.isInteractable) {\n                interactables.push(object)\n            }\n        }\n\n        return interactables\n    }, [ objects ])\n}\n\nexport default useInteractableObjects","import { useContext, useEffect, useState } from \"react\"\nimport TilemapContext from \"./TilemapContext\"\n\nconst useTiles = () => {\n    const { map } = useContext(TilemapContext)\n    const [tiles, set] = useState([])\n\n    useEffect(() => {\n        if (map) {\n            const newTiles = map.layers\n                .filter(layer => layer.type === 'tile')\n                .map(layer => layer.tiles)\n                .flat()\n                .filter(tile => tile !== null)\n\n            set(newTiles)\n        }\n    }, [ map ])\n\n    return tiles\n}\n\nexport default useTiles"],"names":["TilemapContext","createContext","getTileSprite","tileType","tile","map","tileset","gid","tilesets","result","firstGid","getTilesetForGID","tileSets","x","width","height","texture","image","tileHeight","tileWidth","spriteIndex","y","Math","floor","rootDir","path","dirname","baseTexture","Texture","from","source","Rectangle","getTileTexture","React","Sprite","key","Layer","layer","visible","sprites","useMemo","type","tiles","push","getSprite","getTileSprites","objects","object","getObjectSprites","Container","alpha","opacity","Tilemap","_ref","children","props","hasForeground","setHasForeground","useState","layers","index","name","Provider","value","tmx","readFile","callback","fetch","then","response","text","useTilemapLoader","tilemapPath","setMap","useEffect","parseFile","err","_layer$tiles","useMap","useContext","useObjects","filter","flat","useSpawnPoint","spawn","find","Point","point","useCollisions","rects","objectGroups","length","rectangle","collisions","useInteractableObjects","interactables","properties","isInteractable","useTiles","set","newTiles"],"mappings":"idAEA,MAAMA,EAAiBC,IC0BjBC,EAAgB,CAACC,EAAUC,EAAMC,KACnC,MAAMC,EAxBe,EAACC,EAAKC,KAC3B,IAAIC,EACJ,IAAK,MAAMH,KAAWE,EACdD,GAAOD,EAAQI,WACfD,EAASH,GAGjB,OAAOG,GAiBSE,CAAiBP,EAAKG,IAAKF,EAAIO,UAE/C,GAAIN,EAAS,CACT,MAAMO,EAAEA,EAAFC,MAAKA,EAALC,OAAYA,GAAWX,EACvBY,EAlBS,EAACZ,EAAMC,EAAKC,KAC/B,MAAMW,MAAEA,EAAFC,WAASA,EAATC,UAAqBA,GAAcb,EACnCc,EAAchB,EAAKG,IAAMD,EAAQI,SAEjCG,EAAKO,GAAeH,EAAMH,MAAQK,GAAcA,EAChDE,EAAIC,KAAKC,MAAMH,GAAeH,EAAMF,OAASG,IAAeA,EAE5DM,EAAUC,EAAKC,QAAQrB,EAAIoB,MAC3BE,EAAcC,EAAQC,KAAM,GAAEL,KAAWlB,EAAQW,MAAMa,UAE7D,WAAWF,EAAQD,EAAa,IAAII,EAAUlB,EAAGQ,EAAGH,EAAYC,GAAzD,EAQaa,CAAe5B,EAAMC,EAAKC,GAG1C,IAAIe,EAAIjB,EAAKiB,EAKb,MAJiB,WAAblB,IACAkB,GAAKN,GAGFkB,gBAACC,GAAOC,IAAM,IAAGtB,KAAKQ,KACzBL,QAASA,EACTH,EAAGA,EACHQ,EAAGA,EACHP,MAAOA,EACPC,OAAQA,GAEf,GCnBCqB,EAAQ,EAAGC,QAAOhC,UACpB,IAAKgC,EAAMC,QACP,YAGJ,MAAMC,EAAUC,EAAQ,IACD,SAAfH,EAAMI,KA/BK,EAACJ,EAAOhC,KAC3B,MAAMkC,EAAU,GAEhB,IAAK,IAAIlB,EAAI,EAAGA,EAAIhB,EAAIU,OAAQM,IAC5B,IAAK,IAAIR,EAAI,EAAGA,EAAIR,EAAIS,MAAOD,IAAK,CAChC,MACMT,EAAOiC,EAAMK,MADT7B,EAAIQ,EAAIhB,EAAIS,cAGlBV,SAAAA,EAAMG,KAAM,GACZgC,EAAQI,KAAKC,EAAU,OAAQxC,EAAMC,GAE5C,CAGL,OAAOkC,GAkBQM,CAAeR,EAAOhC,GACP,WAAfgC,EAAMI,KAhBA,EAACJ,EAAOhC,IACtBgC,EAAMS,QAAQzC,IAAK0C,IACtB,GAAIA,EAAOxC,IACP,OAAOqC,EAAU,SAAUG,EAAQ1C,EACtC,GAaU2C,CAAiBX,EAAOhC,UAEpC,CAACgC,IAEJ,OAAOJ,gBAACgB,GAAUC,MAAOb,EAAMc,SAAUZ,EAAlC,ECrCLa,EAAUC,QAAChD,IAAEA,EAAFiD,SAAOA,KAAaC,2JACjC,MAAOC,EAAeC,GAAoBC,GAAS,GAE7CC,EAASnB,EAAQ,UACZnC,SAAAA,EAAKsD,OAAOtD,IAAI,CAACgC,EAAOuB,KAC3B,MAAMC,KAAEA,GAASxB,EACjB,MAAa,eAATwB,GACAJ,GAAiB,GACVH,GAEArB,gBAACG,GAAMD,IAAKyB,EAAOvB,MAAOA,EAAOhC,IAAKA,GAChD,GAEN,CAACA,EAAKiD,IAIT,OAAIjD,EAEI4B,gBAACjC,EAAe8D,UAASC,MAAO,CAAE1D,QAC9B4B,gBAACgB,EAAcM,EACVI,GAGCH,GAAiBF,QAMlC,EChCLU,EAAIC,SAAW,CAACxC,EAAMyC,KAClBC,MAAM1C,GACD2C,KAAKC,GAAYA,EAASC,QAC1BF,KAAKE,GAAQJ,EAAS,KAAMI,KAG/BC,MAAAA,EAAoBC,IACtB,MAAOnE,EAAKoE,GAAUf,EAAS,MA4B/B,OA1BAgB,EAAU,KACNV,EAAIW,UAAUH,EAAa,CAACI,EAAKvE,KAC7B,GAAIuE,EAAK,MAAMA,EAIfvE,EAAIsD,OAAStD,EAAIsD,OAAOtD,IAAIgC,UACxB,YACOA,GACHK,eAAOL,EAAMK,cAANmC,EAAaxE,IAAI,CAACD,EAAMwD,SAMfxD,GAAMS,EALP+C,EAAQvD,EAAIS,MAAST,EAAIc,UAKfE,EAJXC,KAAKC,MAAMqC,EAAQvD,EAAIS,OAAST,EAAIa,WAItBJ,MAHVT,EAAIc,UAGaJ,OAFhBV,EAAIa,kBAO/Bb,EAAIoB,KAAO+C,EAEXC,EAAOpE,MAEZ,CAAEmE,IAEEnE,GCnCLyE,EAAS,KACX,MAAMzE,IAAEA,GAAQ0E,EAAW/E,GAC3B,OAAOK,GCFL2E,EAAa,KACf,MAAM3E,IAAEA,GAAQ0E,EAAW/E,GAQ3B,OANgBwC,EAAQ,IAAMnC,EAAIsD,OAC7BsB,OAAO5C,GAAwB,WAAfA,EAAMI,MACtBpC,IAAIgC,GAASA,EAAMS,SACnBoC,OACL,CAAE7E,GAEKyC,ECRLqC,EAAgB,KAClB,MAAMrC,EAAUkC,IAOhB,OALcxC,EAAQ,KAClB,MAAM4C,EAAQtC,EAAQuC,KAAKtC,GAA0B,UAAhBA,EAAOc,MAC5C,WAAWyB,EAAMF,EAAMvE,EAAIuE,EAAMtE,MAAQ,EAAGsE,EAAM/D,EAAI+D,EAAMrE,OAAS,EAA9D,EAGJwE,ECRLC,EAAgB,KAClB,MAAMnF,IAAEA,GAAQ0E,EAAW/E,GA0B3B,OAxBmBwC,EAAQ,IAChBnC,EAAIsD,OACNsB,OAAO5C,GAAwB,SAAfA,EAAMI,MACtBpC,IAAIgC,IACD,MAAMoD,EAAQ,GAEd,IAAK,MAAMrF,KAAQiC,EAAMK,MACrB,GAAItC,EAAM,CACN,MAAMsF,aAAEA,GAAiBtF,EAEzB,GAAIsF,EAAaC,OAAS,EACtB,IAAK,MAAMC,KAAaF,EAAc,CAClC,MAAM7E,EAAEA,EAAFQ,EAAKA,EAALP,MAAQA,EAARC,OAAeA,GAAW6E,EAChCH,EAAM9C,KAAK,IAAIZ,EAAU3B,EAAKS,EAAIA,EAAGT,EAAKiB,EAAIA,EAAGP,EAAOC,GAC3D,CAER,CAGL,OAAO0E,IAEVP,OACN,CAAE7E,GAEEwF,EC5BLC,EAAyB,KAC3B,MAAMhD,EAAUkC,IAEhB,OAAOxC,EAAQ,KACX,MAAMuD,EAAgB,GAEtB,IAAK,MAAMhD,KAAUD,EACbC,EAAOiD,WAAWC,gBAClBF,EAAcpD,KAAKI,GAI3B,OAAOgD,GACR,CAAEjD,GAVS,ECHZoD,EAAW,KACb,MAAM7F,IAAEA,GAAQ0E,EAAW/E,IACpB0C,EAAOyD,GAAOzC,EAAS,IAc9B,OAZAgB,EAAU,KACN,GAAIrE,EAAK,CACL,MAAM+F,EAAW/F,EAAIsD,OAChBsB,OAAO5C,GAAwB,SAAfA,EAAMI,MACtBpC,IAAIgC,GAASA,EAAMK,OACnBwC,OACAD,OAAO7E,GAAiB,OAATA,GAEpB+F,EAAIC,EACP,GACF,CAAE/F,IAEEqC"}