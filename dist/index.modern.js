import t,{createContext as e,useMemo as r,useState as n,useEffect as i,useContext as o}from"react";import{Sprite as l,Container as a}from"@pixi/react";import s from"path";import{Texture as c,Rectangle as h,Point as p}from"pixi.js";import u from"tmx-parser";function f(){return f=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(t[n]=r[n])}return t},f.apply(this,arguments)}const m=e(),d=(e,r,n)=>{const i=((t,e)=>{let r;for(const n of e)t>=n.firstGid&&(r=n);return r})(r.gid,n.tileSets);if(i){const{x:o,width:a,height:p}=r,u=((t,e,r)=>{const{image:n,tileHeight:i,tileWidth:o}=r,l=t.gid-r.firstGid,a=l%(n.width/o)*o,p=Math.floor(l/(n.height/i))*i,u=s.dirname(e.path),f=c.from(`${u}/${r.image.source}`);return new c(f,new h(a,p,i,o))})(r,n,i);let f=r.y;return"object"===e&&(f-=p),t.createElement(l,{key:`(${o},${f})`,texture:u,x:o,y:f,width:a,height:p})}},y=({layer:e,map:n})=>{if(!e.visible)return null;const i=r(()=>"tile"===e.type?((t,e)=>{const r=[];for(let n=0;n<e.height;n++)for(let i=0;i<e.width;i++){const o=t.tiles[i+n*e.width];(null==o?void 0:o.gid)>0&&r.push(d("tile",o,e))}return r})(e,n):"object"===e.type?((t,e)=>t.objects.map(t=>{if(t.gid)return d("object",t,e)}))(e,n):void 0,[e]);return t.createElement(a,{alpha:e.opacity},i)},g=e=>{let{map:i,children:o}=e,l=function(t,e){if(null==t)return{};var r,n,i={},o=Object.keys(t);for(n=0;n<o.length;n++)e.indexOf(r=o[n])>=0||(i[r]=t[r]);return i}(e,["map","children"]);const[s,c]=n(!1),h=r(()=>null==i?void 0:i.layers.map((e,r)=>{const{name:n}=e;return"Foreground"===n?(c(!0),o):t.createElement(y,{key:r,layer:e,map:i})}),[i,o]);return i?t.createElement(m.Provider,{value:{map:i}},t.createElement(a,l,h,!s&&o)):null};u.readFile=(t,e)=>{fetch(t).then(t=>t.text()).then(t=>e(null,t))};const w=t=>{const[e,r]=n(null);return i(()=>{u.parseFile(t,(e,n)=>{if(e)throw e;n.layers=n.layers.map(t=>{var e;return f({},t,{tiles:null==(e=t.tiles)?void 0:e.map((t,e)=>f({},t,{x:e%n.width*n.tileWidth,y:Math.floor(e/n.width)*n.tileHeight,width:n.tileWidth,height:n.tileHeight}))})}),n.path=t,r(n)})},[t]),e},b=()=>{const{map:t}=o(m);return t},x=()=>{const{map:t}=o(m);return r(()=>t.layers.filter(t=>"object"===t.type).map(t=>t.objects).flat(),[t])},v=()=>{const t=x();return r(()=>{const e=t.find(t=>"Spawn"===t.name);return new p(e.x+e.width/2,e.y+e.height/2)})},j=()=>{const{map:t}=o(m);return r(()=>t.layers.filter(t=>"tile"===t.type).map(t=>{const e=[];for(const r of t.tiles)if(r){const{objectGroups:t}=r;if(t.length>0)for(const n of t){const{x:t,y:i,width:o,height:l}=n;e.push(new h(r.x+t,r.y+i,o,l))}}return e}).flat(),[t])},E=()=>{const t=x();return r(()=>{const e=[];for(const r of t)r.properties.isInteractable&&e.push(r);return e},[t])},O=()=>{const{map:t}=o(m),[e,r]=n([]);return i(()=>{if(t){const e=t.layers.filter(t=>"tile"===t.type).map(t=>t.tiles).flat().filter(t=>null!==t);r(e)}},[t]),e};export{g as Tilemap,j as useCollisions,E as useInteractables,b as useMap,x as useObjects,v as useSpawnPoint,w as useTilemapLoader,O as useTiles};
//# sourceMappingURL=index.modern.js.map
