import t,{createContext as e,useMemo as r,useState as i,useEffect as n,useContext as o}from"react";import{Sprite as l,Container as a}from"@pixi/react";import s from"path";import{Texture as c,Rectangle as h,Point as p}from"pixi.js";import f from"tmx-parser";function u(){return u=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(t[i]=r[i])}return t},u.apply(this,arguments)}const m=e(),d=(e,r,i)=>{const n=((t,e)=>{let r;for(const i of e)t>=i.firstGid&&(r=i);return r})(r.gid,i.tileSets);if(n){const{x:o,width:a,height:p}=r,f=((t,e,r)=>{const{image:i,tileHeight:n,tileWidth:o}=r,l=t.gid-r.firstGid,a=l%(i.width/o)*o,p=Math.floor(l/(i.height/n))*n,f=s.dirname(e.path),u=c.from(`${f}/${r.image.source}`);return new c(u,new h(a,p,n,o))})(r,i,n);let u=r.y;return"object"===e&&(u-=p),t.createElement(l,{key:`(${o},${u})`,texture:f,x:o,y:u,width:a,height:p})}},y=({layer:e,map:i})=>{if(!e.visible)return null;const n=r(()=>"tile"===e.type?((t,e)=>{const r=[];for(let i=0;i<e.height;i++)for(let n=0;n<e.width;n++){const o=t.tiles[n+i*e.width];(null==o?void 0:o.gid)>0&&r.push(d("tile",o,e))}return r})(e,i):"object"===e.type?((t,e)=>t.objects.map(t=>{if(t.gid)return d("object",t,e)}))(e,i):void 0,[e]);return t.createElement(a,{alpha:e.opacity},n)},g=e=>{let{map:n,children:o}=e,l=function(t,e){if(null==t)return{};var r,i,n={},o=Object.keys(t);for(i=0;i<o.length;i++)e.indexOf(r=o[i])>=0||(n[r]=t[r]);return n}(e,["map","children"]);const[s,c]=i(!1),h=r(()=>null==n?void 0:n.layers.map((e,r)=>{const{name:i}=e;return"Foreground"===i?(c(!0),o):t.createElement(y,{key:r,layer:e,map:n})}),[n,o]);return n?t.createElement(m.Provider,{value:{map:n}},t.createElement(a,l,h,!s&&o)):null};f.readFile=(t,e)=>{fetch(t).then(t=>t.text()).then(t=>e(t))};const w=t=>{const[e,r]=i(null);return n(()=>{f.parseFile(t,(e,i)=>{if(e)throw e;i.layers=i.layers.map(t=>{var e;return u({},t,{tiles:null==(e=t.tiles)?void 0:e.map((t,e)=>u({},t,{x:e%i.width*i.tileWidth,y:Math.floor(e/i.width)*i.tileHeight,width:i.tileWidth,height:i.tileHeight}))})}),i.path=t,r(i)})},[t]),e},b=()=>{const{map:t}=o(m);return t},x=()=>{const{map:t}=o(m);return r(()=>t.layers.filter(t=>"object"===t.type).map(t=>t.objects).flat(),[t])},v=()=>{const t=x();return r(()=>{const e=t.find(t=>"Spawn"===t.name);return new p(e.x+e.width/2,e.y+e.height/2)})},j=()=>{const{map:t}=o(m);return r(()=>t.layers.filter(t=>"tile"===t.type).map(t=>{const e=[];for(const r of t.tiles)if(r){const{objectGroups:t}=r;if(t.length>0)for(const i of t){const{x:t,y:n,width:o,height:l}=i;e.push(new h(r.x+t,r.y+n,o,l))}}return e}).flat(),[t])},E=()=>{const t=x();return r(()=>{const e=[];for(const r of t)r.properties.isInteractable&&e.push(r);return e},[t])},O=()=>{const{map:t}=o(m),[e,r]=i([]);return n(()=>{if(t){const e=t.layers.filter(t=>"tile"===t.type).map(t=>t.tiles).flat().filter(t=>null!==t);r(e)}},[t]),e};export{g as Tilemap,j as useCollisions,E as useInteractables,b as useMap,x as useObjects,v as useSpawnPoint,w as useTilemapLoader,O as useTiles};
//# sourceMappingURL=index.modern.js.map
